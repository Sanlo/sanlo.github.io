<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta use_mermaid="true" />
  <title>C/C++内存管理详解</title>
  <meta name="description" content="内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或..." />

  <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon" />
  <link rel="icon" href="/favicon.ico?" type="image/x-icon" />
  <link rel="stylesheet" href="/css/fontawesome/css/font-awesome.min.css "> <link rel="stylesheet" href="/css/main.css ">
  <link rel="canonical" href="http://sanlo.github.io/2016/11/08/Cpp-Memory-Management/" />
  <link rel="alternate" type="application/rss+xml" title="Sanlo Zhang" href="http://sanlo.github.io/feed.xml ">
</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">Sanlo Zhang</a>
        <small></small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                        <a href="/">
                    
                    <i class="fa fa-home"></i>Home
                    </a>
                </li>

                
                    
                    <li>
                        
                            <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                            <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                            <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>Tags
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                            <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" post>
    <div class="left">
        <h1>C/C++内存管理详解</h1>
        <div class="label">

            <div class="label-card">
                <i class="fa fa-calendar"></i>2016-11-08
            </div>

            <div class="label-card">
                
            </div>

            <div class="label-card">
                
            </div>

            <div class="label-card">
                


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#C++之禅" title="Category: C++之禅" rel="category">C++之禅</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


            </div>

            <div class="label-card">
                
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <!--a href="/tag/#C%2B%2B" title="Tag: C++" rel="tag">C++</a-->
        <a href="/tag/#C++" title="Tag: C++" rel="tag">C++</a>&nbsp;
    
        <!--a href="/tag/#%E5%86%85%E5%AD%98" title="Tag: 内存" rel="tag">内存</a-->
        <a href="/tag/#内存" title="Tag: 内存" rel="tag">内存</a>
    
  

</span>

            </div>

        </div>
        <hr>
        <article itemscope itemtype="http://schema.org/BlogPosting">
            <ul id="markdown-toc">
  <li><a href="#内存分配方式" id="markdown-toc-内存分配方式">内存分配方式</a>    <ul>
      <li><a href="#简介" id="markdown-toc-简介">简介</a></li>
      <li><a href="#明确区分堆与栈" id="markdown-toc-明确区分堆与栈">明确区分堆与栈</a></li>
      <li><a href="#堆和栈究竟有什么区别" id="markdown-toc-堆和栈究竟有什么区别">堆和栈究竟有什么区别</a></li>
    </ul>
  </li>
  <li><a href="#控制c的内存分配" id="markdown-toc-控制c的内存分配">控制C++的内存分配</a>    <ul>
      <li><a href="#重载全局的new和delete操作符" id="markdown-toc-重载全局的new和delete操作符">重载全局的new和delete操作符</a></li>
      <li><a href="#为单个的类重载new和delete" id="markdown-toc-为单个的类重载new和delete">为单个的类重载new[]和delete[]</a></li>
    </ul>
  </li>
  <li><a href="#常见的内存错误及其对策" id="markdown-toc-常见的内存错误及其对策">常见的内存错误及其对策</a></li>
  <li><a href="#指针与数组的对比" id="markdown-toc-指针与数组的对比">指针与数组的对比</a>    <ul>
      <li><a href="#修改内容" id="markdown-toc-修改内容">修改内容　　</a></li>
      <li><a href="#内容复制与比较" id="markdown-toc-内容复制与比较">内容复制与比较</a></li>
      <li><a href="#计算内存容量" id="markdown-toc-计算内存容量">计算内存容量</a></li>
    </ul>
  </li>
  <li><a href="#指针参数是如何传递内存的" id="markdown-toc-指针参数是如何传递内存的">指针参数是如何传递内存的</a></li>
  <li><a href="#杜绝野指针" id="markdown-toc-杜绝野指针">杜绝“野指针”</a></li>
  <li><a href="#有了mallocfree为什么还要newdelete" id="markdown-toc-有了mallocfree为什么还要newdelete">有了malloc/free为什么还要new/delete</a></li>
  <li><a href="#内存耗尽怎么办" id="markdown-toc-内存耗尽怎么办">内存耗尽怎么办</a></li>
  <li><a href="#mallocfree的使用要点" id="markdown-toc-mallocfree的使用要点">malloc/free的使用要点</a></li>
  <li><a href="#newdelete的使用要点" id="markdown-toc-newdelete的使用要点">new/delete的使用要点</a></li>
  <li><a href="#结论" id="markdown-toc-结论">结论</a></li>
</ul>

<style>
pre {
    overflow-x: auto;
    overflow-y: auto;
    max-height: 300px;
}
</style>

<p>  内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放弃了C++超绝的性能。</p>

<p>  伟大的Bill Gates 曾经失言：</p>
<blockquote>
  <p>640K ought to be enough for everybody — Bill Gates 1981</p>
</blockquote>

<p>  程序员们经常编写内存管理程序，往往提心吊胆。如果不想触雷，唯一的解决办法就是发现所有潜伏的地雷并且排除它们，躲是躲不了的。</p>

<h2 id="内存分配方式">内存分配方式</h2>

<h3 id="简介">简介</h3>
<p>  在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</p>

<p>  <strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>

<p>  <strong>堆</strong>：就是那些由<code class="language-plaintext highlighter-rouge">new</code>分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<code class="language-plaintext highlighter-rouge">new</code>就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p>

<p>  <strong>自由存储区</strong>：就是那些由<code class="language-plaintext highlighter-rouge">malloc</code>等分配的内存块，他和堆是十分相似的，不过它是用<code class="language-plaintext highlighter-rouge">free</code>来结束自己的生命的。</p>

<p>  <strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p>

<p>  <strong>常量存储区</strong>：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p>

<h3 id="明确区分堆与栈">明确区分堆与栈</h3>
<p>  堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。首先，我们举一个例子：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="p">}</span>
</code></pre></div></div>
<p>  这条短短的一句话就包含了堆与栈，看到<code class="language-plaintext highlighter-rouge">new</code>，我们首先就应该想到，我们分配了一块堆内存，那么指针<code class="language-plaintext highlighter-rouge">p</code>呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针<code class="language-plaintext highlighter-rouge">p</code>。在程序会先确定在堆中分配内存的大小，然后调用<code class="language-plaintext highlighter-rouge">operator new</code>分配内存，然后返回这块内存的首地址，放入栈中，他在VC6下的汇编代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00401028 push 14h
0040102A call operator new (00401060)
0040102F add esp,4
00401032 mov dword ptr [ebp-8],eax
00401035 mov eax,dword ptr [ebp-8]
00401038 mov dword ptr [ebp-4],eax
</code></pre></div></div>
<p>  这里，我们为了简单并没有释放内存，那么该怎么去释放呢？是<code class="language-plaintext highlighter-rouge">delete p</code>么？澳，错了，应该是<code class="language-plaintext highlighter-rouge">delete []p</code>，这是为了告诉编译器：我删除的是一个数组，编译器就会根据相应的<code class="language-plaintext highlighter-rouge">Cookie</code>信息去进行释放内存的工作。</p>

<h3 id="堆和栈究竟有什么区别">堆和栈究竟有什么区别</h3>

<p>  好了，我们回到我们的主题：堆和栈究竟有什么区别？</p>

<p>  主要的区别由以下几点：<br />
　　(1). 管理方式不同<br />
　　(2). 空间大小不同<br />
　　(3). 能否产生碎片不同<br />
　　(4). 生长方向不同<br />
　　(5). 分配方式不同<br />
　　(6). 分配效率不同<br />
  <strong>管理方式</strong>：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br />
  <strong>空间大小</strong>：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：<br />
　　打开工程，依次操作菜单如下：<code class="language-plaintext highlighter-rouge">Project-&gt;Setting-&gt;Link</code>，在<code class="language-plaintext highlighter-rouge">Category</code> 中选中<code class="language-plaintext highlighter-rouge">Output</code>，然后在<code class="language-plaintext highlighter-rouge">Reserve</code>中设定堆栈的最大值和<code class="language-plaintext highlighter-rouge">commit</code>。<br />
　　注意：reserve最小值为4Byte；<code class="language-plaintext highlighter-rouge">commit</code>是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。<br />
  <strong>碎片问题</strong>：对于堆来讲，频繁的<code class="language-plaintext highlighter-rouge">new/delete</code>势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。<br />
　　生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br />
  <strong>分配方式</strong>：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由<code class="language-plaintext highlighter-rouge">alloca</code>函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。<br />
  <strong>分配效率</strong>：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。<br />
　　从这里我们可以看到，堆和栈相比，由于大量<code class="language-plaintext highlighter-rouge">new/delete</code>的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。<br />
　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。<br />
　　无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候<code class="language-plaintext highlighter-rouge">debug</code>可是相当困难的：）</p>

<h2 id="控制c的内存分配">控制C++的内存分配</h2>

<p>  在嵌入式系统中使用C++的一个常见问题是内存分配，即对<code class="language-plaintext highlighter-rouge">new</code> 和 <code class="language-plaintext highlighter-rouge">delete</code> 操作符的失控。<br />
　　具有讽刺意味的是，问题的根源却是C++对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。<br />
　　这当然是个好事情，但是这种使用的简单性使得程序员们过度使用<code class="language-plaintext highlighter-rouge">new</code> 和 <code class="language-plaintext highlighter-rouge">delete</code>，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。<br />
　　作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。<br />
　　但当你必须要使用<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>时，你不得不控制C++中的内存分配。你需要用一个全局的<code class="language-plaintext highlighter-rouge">new</code> 和<code class="language-plaintext highlighter-rouge">delete</code>来代替系统的内存分配符，并且一个类一个类的重载<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>。<br />
  一个防止堆破碎的通用方法是从不同固定大小的内存持中分配不同类型的对象。对每个类重载<code class="language-plaintext highlighter-rouge">new</code> 和<code class="language-plaintext highlighter-rouge">delete</code>就提供了这样的控制。</p>

<h3 id="重载全局的new和delete操作符">重载全局的new和delete操作符</h3>

<p>  可以很容易地重载<code class="language-plaintext highlighter-rouge">new</code> 和 <code class="language-plaintext highlighter-rouge">delete</code> 操作符，如下所示:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">){</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  这段代码可以代替默认的操作符来满足内存分配的请求。出于解释C++的目的，我们也可以直接调用<code class="language-plaintext highlighter-rouge">malloc()</code> 和<code class="language-plaintext highlighter-rouge">free()</code>。也可以对单个类的<code class="language-plaintext highlighter-rouge">new</code> 和 <code class="language-plaintext highlighter-rouge">delete</code>操作符重载。这是你能灵活的控制对象的内存分配。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TestClass</span> <span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
    <span class="c1">// .. other members here ...</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">TestClass</span><span class="o">::</span><span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">){</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="c1">// Replace this with alternative allocator</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">TestClass</span><span class="o">::</span><span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// Replace this with alternative de-allocator</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  所有<code class="language-plaintext highlighter-rouge">TestClass</code> 对象的内存分配都采用这段代码。更进一步，任何从<code class="language-plaintext highlighter-rouge">TestClass</code> 继承的类也都采用这一方式，除非它自己也重载了<code class="language-plaintext highlighter-rouge">new</code> 和 <code class="language-plaintext highlighter-rouge">delete</code> 操作符。通过重载<code class="language-plaintext highlighter-rouge">new</code> 和 <code class="language-plaintext highlighter-rouge">delete</code> 操作符的方法，你可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。</p>

<h3 id="为单个的类重载new和delete">为单个的类重载new[]和delete[]</h3>

<p>  必须小心对象数组的分配。你可能希望调用到被你重载过的<code class="language-plaintext highlighter-rouge">new</code> 和 <code class="language-plaintext highlighter-rouge">delete</code> 操作符，但并不如此。内存的请求被定向到全局的<code class="language-plaintext highlighter-rouge">new[]</code>和<code class="language-plaintext highlighter-rouge">delete[]</code> 操作符，而这些内存来自于系统堆。</p>

<p>  C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载<code class="language-plaintext highlighter-rouge">new[]</code> 和 <code class="language-plaintext highlighter-rouge">delete[]</code>操作符。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TestClass</span> <span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">[</span> <span class="p">](</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">[</span> <span class="p">](</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
    <span class="c1">// .. other members here ..</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">TestClass</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">[</span> <span class="p">](</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">){</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">TestClass</span><span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">[</span> <span class="p">](</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">TestClass</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestClass</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="c1">// ... etc ...</span>
    <span class="k">delete</span><span class="p">[</span> <span class="p">]</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  但是注意：对于多数C++的实现，<code class="language-plaintext highlighter-rouge">new[]</code>操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制重要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。</p>

<h2 id="常见的内存错误及其对策">常见的内存错误及其对策</h2>

<p>  发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。 常见的内存错误及其对策如下：</p>

<ul>
  <li>内存分配未成功，却使用了它。编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为<code class="language-plaintext highlighter-rouge">NULL</code>。如果指针<code class="language-plaintext highlighter-rouge">p</code>是函数的参数，那么在函数的入口处用<code class="language-plaintext highlighter-rouge">assert(p!=NULL)</code>进行检查。如果是用<code class="language-plaintext highlighter-rouge">malloc</code>或<code class="language-plaintext highlighter-rouge">new</code>来申请内存，应该用<code class="language-plaintext highlighter-rouge">if(p==NULL)</code> 或<code class="language-plaintext highlighter-rouge">if(p!=NULL)</code>进行防错处理。</li>
  <li>内存分配虽然成功，但是尚未初始化就引用它。犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</li>
  <li>内存分配成功并且已经初始化，但操作越过了内存的边界。例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在<code class="language-plaintext highlighter-rouge">for</code>循环语句中，循环次数很容易搞错，导致数组操作越界。</li>
  <li>忘记了释放内存，造成内存泄露。含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中<code class="language-plaintext highlighter-rouge">malloc</code>与<code class="language-plaintext highlighter-rouge">free</code>的使用次数一定要相同，否则肯定有错误（<code class="language-plaintext highlighter-rouge">new/delete</code>同理）。</li>
  <li>释放了内存却继续使用它。<br />
  有三种情况：<br />
　　(1). 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。<br />
　　(2). 函数的<code class="language-plaintext highlighter-rouge">return</code>语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。<br />
　　(3). 使用<code class="language-plaintext highlighter-rouge">free</code>或<code class="language-plaintext highlighter-rouge">delete</code>释放了内存后，没有将指针设置为<code class="language-plaintext highlighter-rouge">NULL</code>。<strong>导致产生“野指针”</strong>。</li>
</ul>

<p>  <strong>那么如何避免产生野指针呢？</strong>这里列出了5条规则，平常写程序时多注意一下，养成良好的习惯。</p>
<blockquote>
  <p>规则1：用<code class="language-plaintext highlighter-rouge">malloc</code>或<code class="language-plaintext highlighter-rouge">new</code>申请内存之后，应该立即检查指针值是否为<code class="language-plaintext highlighter-rouge">NULL</code>。防止使用指针值为<code class="language-plaintext highlighter-rouge">NULL</code>的内存。<br />
规则2：不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。<br />
规则3：避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。<br />
规则4：动态内存的申请与释放必须配对，防止内存泄漏。<br />
规则5：用<code class="language-plaintext highlighter-rouge">free</code>或<code class="language-plaintext highlighter-rouge">delete</code>释放了内存之后，立即将指针设置为<code class="language-plaintext highlighter-rouge">NULL</code>，防止产生“野指针”。</p>
</blockquote>

<h2 id="指针与数组的对比">指针与数组的对比</h2>

<p>  C++/C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。<br />
　　数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。<br />
　　指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。<br />
　　下面以字符串为例比较指针与数组的特性。</p>

<h3 id="修改内容">修改内容　　</h3>
<p>  下面示例中，字符数组a的容量是6个字符，其内容为 hello。a的内容可以改变，如<code class="language-plaintext highlighter-rouge">a[0]= 'X'</code>。指针p指向常量字符串“world”（位于静态存储区，内容为world），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句<code class="language-plaintext highlighter-rouge">p[0]= 'X'</code>有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'X'</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">;</span> 	<span class="c1">// 注意p指向常量字符串</span>
<span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'X'</span><span class="p">;</span> 		<span class="c1">// 编译器不能发现该错误</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="内容复制与比较">内容复制与比较</h3>

<p>  不能对数组名进行直接复制与比较。若想把数组a的内容复制给数组b，不能用语句 <code class="language-plaintext highlighter-rouge">b = a</code> ，否则将产生编译错误。应该用标准库函数<code class="language-plaintext highlighter-rouge">strcpy</code>进行复制。同理，比较b和a的内容是否相同，不能用<code class="language-plaintext highlighter-rouge">if(b==a)</code> 来判断，应该用标准库函数<code class="language-plaintext highlighter-rouge">strcmp</code>进行比较。<br />
　　语句 <code class="language-plaintext highlighter-rouge">p = a</code> 并不能把a的内容复制指针<code class="language-plaintext highlighter-rouge">p</code>，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数<code class="language-plaintext highlighter-rouge">malloc</code>为p申请一块容量为<code class="language-plaintext highlighter-rouge">strlen(a)+1</code>个字符的内存，再用<code class="language-plaintext highlighter-rouge">strcpy</code>进行字符串复制。同理，语句<code class="language-plaintext highlighter-rouge">if(p==a)</code> 比较的不是内容而是地址，应该用库函数<code class="language-plaintext highlighter-rouge">strcmp</code>来比较。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 数组…</span>
<span class="kt">char</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// 不能用 b = a;</span>
<span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 不能用 if (b == a)</span>

<span class="c1">// 指针…</span>
<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 不要用 p = a;</span>
<span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 不要用 if (p == a)</span>

</code></pre></div></div>
<h3 id="计算内存容量">计算内存容量</h3>
<p>  用运算符<code class="language-plaintext highlighter-rouge">sizeof</code>可以计算出数组的容量（字节数）。如下示例中，<code class="language-plaintext highlighter-rouge">sizeof(a)</code>的值是12（注意别忘了’’）。指针<code class="language-plaintext highlighter-rouge">p</code>指向a，但是<code class="language-plaintext highlighter-rouge">sizeof(p)</code>的值却是4。这是因为<code class="language-plaintext highlighter-rouge">sizeof(p)</code>得到的是一个指针变量的字节数，相当于<code class="language-plaintext highlighter-rouge">sizeof(char*)</code>，而不是<code class="language-plaintext highlighter-rouge">p</code>所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 12字节</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 4字节</span>
</code></pre></div></div>
<p>  注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，<code class="language-plaintext highlighter-rouge">sizeof(a)</code>始终等于<code class="language-plaintext highlighter-rouge">sizeof(char *)</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Func</span><span class="p">(</span><span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">]){</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 4字节而不是100字节</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="指针参数是如何传递内存的">指针参数是如何传递内存的</h2>

<p>  如果函数的参数是一个指针，不要指望用该指针去申请动态内存。如下示例中，Test函数的语句<code class="language-plaintext highlighter-rouge">GetMemory(str, 200)</code>并没有使<code class="language-plaintext highlighter-rouge">str</code>获得期望的内存，<code class="language-plaintext highlighter-rouge">str</code>依旧是<code class="language-plaintext highlighter-rouge">NULL</code>，为什么？</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">GetMemory</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">){</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">Test</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">GetMemory</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span> <span class="c1">// str 仍然为 NULL</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">);</span> <span class="c1">// 运行错误</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  毛病出在函数<code class="language-plaintext highlighter-rouge">GetMemory</code>中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 <code class="language-plaintext highlighter-rouge">_p</code>，编译器使 <code class="language-plaintext highlighter-rouge">_p=p</code>。如果函数体内的程序修改了<code class="language-plaintext highlighter-rouge">_p</code>的内容，就导致参数<code class="language-plaintext highlighter-rouge">p</code>的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，<code class="language-plaintext highlighter-rouge">_p</code>申请了新的内存，只是把 <code class="language-plaintext highlighter-rouge">_p</code>所指的内存地址改变了，但是<code class="language-plaintext highlighter-rouge">p</code>丝毫未变。所以函数<code class="language-plaintext highlighter-rouge">GetMemory</code>并不能输出任何东西。事实上，每执行一次<code class="language-plaintext highlighter-rouge">GetMemory</code>就会泄露一块内存，因为没有用<code class="language-plaintext highlighter-rouge">free</code>释放内存。<br />
　　如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”，见示例：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">GetMemory2</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">){</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">Test2</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">GetMemory2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span> <span class="c1">// 注意参数是 &amp;str，而不是str</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="n">free</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单，见示例：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="nf">GetMemory3</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="n">num</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">Test3</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">str</span> <span class="o">=</span> <span class="n">GetMemory3</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    
    <span class="n">strcpy</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把<code class="language-plaintext highlighter-rouge">return</code>语句用错了。这里强调不要用<code class="language-plaintext highlighter-rouge">return</code>语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡，见示例：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="nf">GetString</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">char</span> <span class="n">p</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// 编译器将提出警告</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">Test4</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">str</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span> <span class="c1">// str 的内容是垃圾</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  用调试器逐步跟踪Test4，发现执行<code class="language-plaintext highlighter-rouge">str = GetString</code>语句后<code class="language-plaintext highlighter-rouge">str</code>不再是<code class="language-plaintext highlighter-rouge">NULL</code>指针，但是<code class="language-plaintext highlighter-rouge">str</code>的内容不是<code class="language-plaintext highlighter-rouge">"hello world"</code>而是垃圾。
如果把上述示例改写成如下示例，会怎么样？</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="nf">GetString2</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">Test5</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">str</span> <span class="o">=</span> <span class="n">GetString2</span><span class="p">();</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  函数Test5运行虽然不会出错，但是函数<code class="language-plaintext highlighter-rouge">GetString2</code>的设计概念却是错误的。因为<code class="language-plaintext highlighter-rouge">GetString2</code>内的<code class="language-plaintext highlighter-rouge">"hello world"</code>是常量字符串，位于静态存储区，它在程序生命期内恒定不变。无论什么时候调用<code class="language-plaintext highlighter-rouge">GetString2</code>，它返回的始终是同一个“只读”的内存块。</p>

<h2 id="杜绝野指针">杜绝“野指针”</h2>

<p>  “野指针”不是<code class="language-plaintext highlighter-rouge">NULL</code>指针，是指向“垃圾”内存的指针。人们一般不会错用<code class="language-plaintext highlighter-rouge">NULL</code>指针，因为用<code class="language-plaintext highlighter-rouge">if</code>语句很容易判断。但是“野指针”是很危险的，<code class="language-plaintext highlighter-rouge">if</code>语句对它不起作用。 “野指针”的成因主要有三种：<br />
　　(1). 指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</code></pre></div></div>
<p>　　  (2). 指针<code class="language-plaintext highlighter-rouge">p</code>被<code class="language-plaintext highlighter-rouge">free</code>或者<code class="language-plaintext highlighter-rouge">delete</code>之后，没有置为<code class="language-plaintext highlighter-rouge">NULL</code>，让人误以为<code class="language-plaintext highlighter-rouge">p</code>是个合法的指针。<br />
　　(3). 指针操作超越了变量的作用域范围。这种情况让人防不胜防，示例程序如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">Func</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Func of class A"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">Test</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">A</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// 注意 a 的生命期</span>
    <span class="p">}</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">Func</span><span class="p">();</span> <span class="c1">// p是"野指针"</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  函数Test在执行语句<code class="language-plaintext highlighter-rouge">p-&gt;Func()</code>时，对象a已经消失，而<code class="language-plaintext highlighter-rouge">p</code>是指向a的，所以<code class="language-plaintext highlighter-rouge">p</code>就成了“野指针”。但奇怪的是我运行这个程序时居然没有出错，这可能与编译器有关。</p>

<h2 id="有了mallocfree为什么还要newdelete">有了malloc/free为什么还要new/delete</h2>

<p>  <code class="language-plaintext highlighter-rouge">malloc</code>与<code class="language-plaintext highlighter-rouge">free</code>是C++/C语言的标准库函数，<code class="language-plaintext highlighter-rouge">new/delete</code>是C++的运算符。它们都可用于申请动态内存和释放内存。<br />
　　对于非内部数据类型的对象而言，光用<code class="language-plaintext highlighter-rouge">maloc/free</code>无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于<code class="language-plaintext highlighter-rouge">malloc/free</code>是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于<code class="language-plaintext highlighter-rouge">malloc/free</code>。<br />
　　因此C++语言需要一个能完成动态内存分配和初始化工作的运算符<code class="language-plaintext highlighter-rouge">new</code>，以及一个能完成清理与释放内存工作的运算符<code class="language-plaintext highlighter-rouge">delete</code>。注意<code class="language-plaintext highlighter-rouge">new/delete</code>不是库函数。我们先看一看<code class="language-plaintext highlighter-rouge">malloc/free</code>和<code class="language-plaintext highlighter-rouge">new/delete</code>如何实现对象的动态内存管理，见示例：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Obj</span><span class="p">{</span>
    <span class="k">public</span> <span class="o">:</span>
<span class="err">　　</span><span class="n">Obj</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Initialization"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="err">　　</span><span class="o">~</span><span class="n">Obj</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destroy"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="err">　　</span><span class="kt">void</span> <span class="n">Initialize</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Initialization"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="err">　　</span><span class="kt">void</span> <span class="n">Destroy</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destroy"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">UseMallocFree</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">Obj</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">obj</span><span class="p">));</span> <span class="c1">// 申请动态内存</span>
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">Initialize</span><span class="p">();</span> <span class="c1">// 初始化</span>
    <span class="c1">//...</span>
    
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">Destroy</span><span class="p">();</span> <span class="c1">// 清除工作</span>
    <span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 释放内存</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">UseNewDelete</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">Obj</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Obj</span><span class="p">;</span> <span class="c1">// 申请动态内存并且初始化</span>
    <span class="c1">//...</span>
    <span class="k">delete</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// 清除并且释放内存</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  类<code class="language-plaintext highlighter-rouge">Obj</code>的函数<code class="language-plaintext highlighter-rouge">Initialize</code>模拟了构造函数的功能，函数<code class="language-plaintext highlighter-rouge">Destroy</code>模拟了析构函数的功能。函数<code class="language-plaintext highlighter-rouge">UseMallocFree</code>中，由于<code class="language-plaintext highlighter-rouge">malloc/free</code>不能执行构造函数与析构函数，必须调用成员函数<code class="language-plaintext highlighter-rouge">Initialize</code>和<code class="language-plaintext highlighter-rouge">Destroy</code>来完成初始化与清除工作。函数<code class="language-plaintext highlighter-rouge">UseNewDelete</code>则简单得多。<br />
　　所以我们不要企图用<code class="language-plaintext highlighter-rouge">malloc/free</code>来完成动态对象的内存管理，应该用<code class="language-plaintext highlighter-rouge">new/delete</code>。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言<code class="language-plaintext highlighter-rouge">malloc/free</code>和<code class="language-plaintext highlighter-rouge">new/delete</code>是等价的。<br />
　　既然<code class="language-plaintext highlighter-rouge">new/delete</code>的功能完全覆盖了<code class="language-plaintext highlighter-rouge">malloc/free</code>，为什么C++不把<code class="language-plaintext highlighter-rouge">malloc/free</code>淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用<code class="language-plaintext highlighter-rouge">malloc/free</code>管理动态内存。<br />
　　如果用<code class="language-plaintext highlighter-rouge">free</code>释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用<code class="language-plaintext highlighter-rouge">delete</code>释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以<code class="language-plaintext highlighter-rouge">new/delete</code>必须配对使用，<code class="language-plaintext highlighter-rouge">malloc/free</code>也一样。</p>

<h2 id="内存耗尽怎么办">内存耗尽怎么办</h2>

<p>  如果在申请动态内存时找不到足够大的内存块，<code class="language-plaintext highlighter-rouge">malloc</code>和<code class="language-plaintext highlighter-rouge">new</code>将返回<code class="language-plaintext highlighter-rouge">NULL</code>指针，宣告内存申请失败。通常有三种方式处理“内存耗尽”问题。<br />
　　(1). 判断指针是否为<code class="language-plaintext highlighter-rouge">NULL</code>，如果是则马上用<code class="language-plaintext highlighter-rouge">return</code>语句终止本函数。例如：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Func</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">A</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  (2). 判断指针是否为<code class="language-plaintext highlighter-rouge">NULL</code>，如果是则马上用<code class="language-plaintext highlighter-rouge">exit(1)</code>终止整个程序的运行。例如：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Func</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">A</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Memory Exhausted"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  (3). 为<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">malloc</code>设置异常处理函数。例如Visual C++可以用<code class="language-plaintext highlighter-rouge">_set_new_hander</code>函数为<code class="language-plaintext highlighter-rouge">new</code>设置用户自己定义的异常处理函数，也可以让<code class="language-plaintext highlighter-rouge">malloc</code>享用与<code class="language-plaintext highlighter-rouge">new</code>相同的异常处理函数。详细内容请参考C++使用手册。<br />
　　上述 (1)、(2) 方式使用最普遍。如果一个函数内有多处需要申请动态内存，那么方式 (1) 就显得力不从心（释放内存很麻烦），应该用方式 (2) 来处理。<br />
　　很多人不忍心用<code class="language-plaintext highlighter-rouge">exit(1)</code>，问：“不编写出错处理程序，让操作系统自己解决行不行？”<br />
　　不行。如果发生“内存耗尽”这样的事情，一般说来应用程序已经无药可救。如果不用<code class="language-plaintext highlighter-rouge">exit(1)</code> 把坏程序杀死，它可能会害死操作系统。道理如同：如果不把歹徒击毙，歹徒在老死之前会犯下更多的罪。<br />
　　有一个很重要的现象要告诉大家。对于32位以上的应用程序而言，无论怎样使用<code class="language-plaintext highlighter-rouge">malloc</code>与<code class="language-plaintext highlighter-rouge">new</code>，几乎不可能导致“内存耗尽”。对于32位以上的应用程序，“内存耗尽”错误处理程序毫无用处。这下可把Unix和Windows程序员们乐坏了：反正错误处理程序不起作用，我就不写了，省了很多麻烦。<br />
　　必须强调：不加错误处理将导致程序的质量很差，千万不可因小失大。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">){</span>
        <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="mi">1000000</span><span class="p">];</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"eat memory"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="mallocfree的使用要点">malloc/free的使用要点</h2>

<p>  函数<code class="language-plaintext highlighter-rouge">malloc</code>的原型如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span> <span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div></div>
<p>  用<code class="language-plaintext highlighter-rouge">malloc</code>申请一块长度为<code class="language-plaintext highlighter-rouge">length</code>的整数类型的内存，程序如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">length</span><span class="p">);</span>
</code></pre></div></div>
<p>  我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。<br />
　　<code class="language-plaintext highlighter-rouge">* malloc</code>返回值的类型是<code class="language-plaintext highlighter-rouge">void*</code>，所以在调用<code class="language-plaintext highlighter-rouge">malloc</code>时要显式地进行类型转换，将<code class="language-plaintext highlighter-rouge">void *</code>转换成所需要的指针类型。<br />
　　<code class="language-plaintext highlighter-rouge">* malloc</code>函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。我们通常记不住<code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">float</code>等数据类型的变量的确切字节数。例如<code class="language-plaintext highlighter-rouge">int</code>变量在16位系统下是2个字节，在32位下是4个字节；而<code class="language-plaintext highlighter-rouge">float</code>变量在16位系统下是4个字节，在32位下也是4个字节。最好用以下程序作一次测试：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>
<p>  在<code class="language-plaintext highlighter-rouge">malloc</code>的“()”中使用<code class="language-plaintext highlighter-rouge">sizeof</code>运算符是良好的风格，但要当心有时我们会昏了头，写出 <code class="language-plaintext highlighter-rouge">p = malloc(sizeof(p))</code>这样的程序来。<br />
　　函数<code class="language-plaintext highlighter-rouge">free</code>的原型如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">free</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">memblock</span> <span class="p">);</span>
</code></pre></div></div>
<p>  为什么<code class="language-plaintext highlighter-rouge">free</code>函数不象<code class="language-plaintext highlighter-rouge">malloc</code>函数那样复杂呢？这是因为指针<code class="language-plaintext highlighter-rouge">p</code>的类型以及它所指的内存的容量事先都是知道的，语句<code class="language-plaintext highlighter-rouge">free(p)</code>能正确地释放内存。如果<code class="language-plaintext highlighter-rouge">p</code>是<code class="language-plaintext highlighter-rouge">NULL</code>指针，那么<code class="language-plaintext highlighter-rouge">free</code>对<code class="language-plaintext highlighter-rouge">p</code>无论操作多少次都不会出问题。如果<code class="language-plaintext highlighter-rouge">p</code>不是<code class="language-plaintext highlighter-rouge">NULL</code>指针，那么<code class="language-plaintext highlighter-rouge">free</code>对<code class="language-plaintext highlighter-rouge">p</code>连续操作两次就会导致程序运行错误。</p>

<h2 id="newdelete的使用要点">new/delete的使用要点</h2>

<p>  运算符<code class="language-plaintext highlighter-rouge">new</code>使用起来要比函数<code class="language-plaintext highlighter-rouge">malloc</code>简单得多，例如：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">length</span><span class="p">);</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">length</span><span class="p">];</span>
</code></pre></div></div>
<p>  这是因为<code class="language-plaintext highlighter-rouge">new</code>内置了<code class="language-plaintext highlighter-rouge">sizeof</code>、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，<code class="language-plaintext highlighter-rouge">new</code>在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么<code class="language-plaintext highlighter-rouge">new</code>的语句也可以有多种形式。例如：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Obj</span><span class="p">{</span>
    <span class="k">public</span> <span class="o">:</span>
    <span class="n">Obj</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="c1">// 无参数的构造函数</span>
    <span class="n">Obj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// 带一个参数的构造函数</span>
    <span class="err">…</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">Test</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">Obj</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Obj</span><span class="p">;</span>
    <span class="n">Obj</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Obj</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 初值为1</span>
    <span class="err">…</span>
    <span class="k">delete</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  如果用<code class="language-plaintext highlighter-rouge">new</code>创建对象数组，那么只能使用对象的无参数构造函数。例如：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Obj</span> <span class="o">*</span><span class="n">objects</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Obj</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span> <span class="c1">// 创建100个动态对象</span>
</code></pre></div></div>
<p>  不能写成：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Obj</span> <span class="o">*</span><span class="n">objects</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Obj</span><span class="p">[</span><span class="mi">100</span><span class="p">](</span><span class="mi">1</span><span class="p">);</span><span class="c1">// 创建100个动态对象的同时赋初值1</span>
</code></pre></div></div>
<p>  在用<code class="language-plaintext highlighter-rouge">delete</code>释放对象数组时，留意不要丢了符号‘[]’。例如：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">delete</span> <span class="p">[]</span><span class="n">objects</span><span class="p">;</span> <span class="c1">// 正确的用法</span>
<span class="k">delete</span> <span class="n">objects</span><span class="p">;</span> <span class="c1">// 错误的用法</span>
</code></pre></div></div>
<p>  后者有可能引起程序崩溃和内存泄漏。</p>
<h2 id="结论">结论</h2>

<ul>
  <li>越是怕指针，就越要使用指针。不会正确使用指针，肯定算不上是合格的程序员。</li>
  <li>必须养成使用“调试器逐步跟踪程序”的习惯，只有这样才能发现问题的本质。</li>
</ul>

        </article>
        <hr>

        
        
            
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
        

        <div class="post-recent">
    <div class="pre">
        
        <p><strong>上一篇</strong> <a href="/2016/11/07/sublimeLinter/">代码校验工具 SublimeLinter 的安装与使用</a></p>
        
    </div>
    <div class="nex">

        
        <p><strong>下一篇</strong> <a href="/2016/11/13/Introduction-to-quantitative-investment-and-machine-learning/">机器学习&量化投资入门</a></p>
        
    </div>
</div>




    </div>
    <button class="anchor"><i class="fa fa-anchor"></i></button>
    <div class="right">
        <div class="wrap">

            <!-- Content -->
            <div class="side content">
                <div>
                    Content
                </div>
                <ul id="content-side" class="content-ul">
                    <!-- <li><a href="#similar_posts">Similar Posts123</a></li>
                    <li><a href="#comments">Comments</a></li> -->
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <!-- <div class="side">bbbb</div> -->
        </div>
    </div>
</div>


<script>
/**
 * target _blank
 */
(function() {
    var aTags = document.querySelectorAll('article a:not([id])')
    for (var i = 0; i < aTags.length; i++) {
        aTags[i].setAttribute('target', '_blank')
    }
}());
</script>
<script src="/js/pageContent.js " charset="utf-8"></script>


    <footer class="site-footer">
  <div class="wrapper">
    <p class="description"> 如果你感受到痛苦，那么，你还活着；如果你感受到他人的痛苦，那么，你才是人。 </p>
    <p class="contact">
      Contact me at: 
      <a href="https://github.com/sanlo" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a>   <a href="mailto:940072028@qq.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>  
      <a href="https://www.linkedin.com/in/sanlozhang" title="LinkedIn"><i class="fa fa-linkedin" aria-hidden="true"></i></a> 
    </p>
    <p class="power">
      <span> Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>. </span>
    </p>
  </div>
</footer>

    <div class="back-to-top">
    <a href="#top" class="scroll">
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /js/main.js " charset="utf-8"></script>
    <script src=" /js/scroll.min.js " charset="utf-8"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.esm.min.mjs';
      mermaid.initialize({ startOnLoad: true });
    </script>
  </body>

</html>
